// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/gzorm/common/zorm/model"
)

func newWinCustomer(db *gorm.DB, opts ...gen.DOOption) winCustomer {
	_winCustomer := winCustomer{}

	_winCustomer.winCustomerDo.UseDB(db, opts...)
	_winCustomer.winCustomerDo.UseModel(&model.WinCustomer{})

	tableName := _winCustomer.winCustomerDo.TableName()
	_winCustomer.ALL = field.NewAsterisk(tableName)
	_winCustomer.ID = field.NewInt64(tableName, "id")
	_winCustomer.CustomerName = field.NewString(tableName, "customer_name")
	_winCustomer.CustomerURL = field.NewString(tableName, "customer_url")
	_winCustomer.CustomerFace = field.NewString(tableName, "customer_face")
	_winCustomer.Language = field.NewString(tableName, "language")
	_winCustomer.Status = field.NewInt64(tableName, "status")
	_winCustomer.CreatedAt = field.NewInt64(tableName, "created_at")
	_winCustomer.UpdatedAt = field.NewInt64(tableName, "updated_at")
	_winCustomer.UpdatedUser = field.NewString(tableName, "updated_user")

	_winCustomer.fillFieldMap()

	return _winCustomer
}

type winCustomer struct {
	winCustomerDo

	ALL          field.Asterisk
	ID           field.Int64
	CustomerName field.String // 客服名称
	CustomerURL  field.String // 客服连接
	CustomerFace field.String // 客服头像
	Language     field.String // 语言
	Status       field.Int64  // 是否启用
	CreatedAt    field.Int64  // 1==禁用  3==正常
	UpdatedAt    field.Int64
	UpdatedUser  field.String // 最后修改人

	fieldMap map[string]field.Expr
}

func (w winCustomer) Table(newTableName string) *winCustomer {
	w.winCustomerDo.UseTable(newTableName)
	return w.updateTableName(newTableName)
}

func (w winCustomer) As(alias string) *winCustomer {
	w.winCustomerDo.DO = *(w.winCustomerDo.As(alias).(*gen.DO))
	return w.updateTableName(alias)
}

func (w *winCustomer) updateTableName(table string) *winCustomer {
	w.ALL = field.NewAsterisk(table)
	w.ID = field.NewInt64(table, "id")
	w.CustomerName = field.NewString(table, "customer_name")
	w.CustomerURL = field.NewString(table, "customer_url")
	w.CustomerFace = field.NewString(table, "customer_face")
	w.Language = field.NewString(table, "language")
	w.Status = field.NewInt64(table, "status")
	w.CreatedAt = field.NewInt64(table, "created_at")
	w.UpdatedAt = field.NewInt64(table, "updated_at")
	w.UpdatedUser = field.NewString(table, "updated_user")

	w.fillFieldMap()

	return w
}

func (w *winCustomer) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := w.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (w *winCustomer) fillFieldMap() {
	w.fieldMap = make(map[string]field.Expr, 9)
	w.fieldMap["id"] = w.ID
	w.fieldMap["customer_name"] = w.CustomerName
	w.fieldMap["customer_url"] = w.CustomerURL
	w.fieldMap["customer_face"] = w.CustomerFace
	w.fieldMap["language"] = w.Language
	w.fieldMap["status"] = w.Status
	w.fieldMap["created_at"] = w.CreatedAt
	w.fieldMap["updated_at"] = w.UpdatedAt
	w.fieldMap["updated_user"] = w.UpdatedUser
}

func (w winCustomer) clone(db *gorm.DB) winCustomer {
	w.winCustomerDo.ReplaceConnPool(db.Statement.ConnPool)
	return w
}

func (w winCustomer) replaceDB(db *gorm.DB) winCustomer {
	w.winCustomerDo.ReplaceDB(db)
	return w
}

type winCustomerDo struct{ gen.DO }

type IWinCustomerDo interface {
	gen.SubQuery
	Debug() IWinCustomerDo
	WithContext(ctx context.Context) IWinCustomerDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IWinCustomerDo
	WriteDB() IWinCustomerDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IWinCustomerDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IWinCustomerDo
	Not(conds ...gen.Condition) IWinCustomerDo
	Or(conds ...gen.Condition) IWinCustomerDo
	Select(conds ...field.Expr) IWinCustomerDo
	Where(conds ...gen.Condition) IWinCustomerDo
	Order(conds ...field.Expr) IWinCustomerDo
	Distinct(cols ...field.Expr) IWinCustomerDo
	Omit(cols ...field.Expr) IWinCustomerDo
	Join(table schema.Tabler, on ...field.Expr) IWinCustomerDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IWinCustomerDo
	RightJoin(table schema.Tabler, on ...field.Expr) IWinCustomerDo
	Group(cols ...field.Expr) IWinCustomerDo
	Having(conds ...gen.Condition) IWinCustomerDo
	Limit(limit int) IWinCustomerDo
	Offset(offset int) IWinCustomerDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IWinCustomerDo
	Unscoped() IWinCustomerDo
	Create(values ...*model.WinCustomer) error
	CreateInBatches(values []*model.WinCustomer, batchSize int) error
	Save(values ...*model.WinCustomer) error
	First() (*model.WinCustomer, error)
	Take() (*model.WinCustomer, error)
	Last() (*model.WinCustomer, error)
	Find() ([]*model.WinCustomer, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.WinCustomer, err error)
	FindInBatches(result *[]*model.WinCustomer, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.WinCustomer) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IWinCustomerDo
	Assign(attrs ...field.AssignExpr) IWinCustomerDo
	Joins(fields ...field.RelationField) IWinCustomerDo
	Preload(fields ...field.RelationField) IWinCustomerDo
	FirstOrInit() (*model.WinCustomer, error)
	FirstOrCreate() (*model.WinCustomer, error)
	FindByPage(offset int, limit int) (result []*model.WinCustomer, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IWinCustomerDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (w winCustomerDo) Debug() IWinCustomerDo {
	return w.withDO(w.DO.Debug())
}

func (w winCustomerDo) WithContext(ctx context.Context) IWinCustomerDo {
	return w.withDO(w.DO.WithContext(ctx))
}

func (w winCustomerDo) ReadDB() IWinCustomerDo {
	return w.Clauses(dbresolver.Read)
}

func (w winCustomerDo) WriteDB() IWinCustomerDo {
	return w.Clauses(dbresolver.Write)
}

func (w winCustomerDo) Session(config *gorm.Session) IWinCustomerDo {
	return w.withDO(w.DO.Session(config))
}

func (w winCustomerDo) Clauses(conds ...clause.Expression) IWinCustomerDo {
	return w.withDO(w.DO.Clauses(conds...))
}

func (w winCustomerDo) Returning(value interface{}, columns ...string) IWinCustomerDo {
	return w.withDO(w.DO.Returning(value, columns...))
}

func (w winCustomerDo) Not(conds ...gen.Condition) IWinCustomerDo {
	return w.withDO(w.DO.Not(conds...))
}

func (w winCustomerDo) Or(conds ...gen.Condition) IWinCustomerDo {
	return w.withDO(w.DO.Or(conds...))
}

func (w winCustomerDo) Select(conds ...field.Expr) IWinCustomerDo {
	return w.withDO(w.DO.Select(conds...))
}

func (w winCustomerDo) Where(conds ...gen.Condition) IWinCustomerDo {
	return w.withDO(w.DO.Where(conds...))
}

func (w winCustomerDo) Order(conds ...field.Expr) IWinCustomerDo {
	return w.withDO(w.DO.Order(conds...))
}

func (w winCustomerDo) Distinct(cols ...field.Expr) IWinCustomerDo {
	return w.withDO(w.DO.Distinct(cols...))
}

func (w winCustomerDo) Omit(cols ...field.Expr) IWinCustomerDo {
	return w.withDO(w.DO.Omit(cols...))
}

func (w winCustomerDo) Join(table schema.Tabler, on ...field.Expr) IWinCustomerDo {
	return w.withDO(w.DO.Join(table, on...))
}

func (w winCustomerDo) LeftJoin(table schema.Tabler, on ...field.Expr) IWinCustomerDo {
	return w.withDO(w.DO.LeftJoin(table, on...))
}

func (w winCustomerDo) RightJoin(table schema.Tabler, on ...field.Expr) IWinCustomerDo {
	return w.withDO(w.DO.RightJoin(table, on...))
}

func (w winCustomerDo) Group(cols ...field.Expr) IWinCustomerDo {
	return w.withDO(w.DO.Group(cols...))
}

func (w winCustomerDo) Having(conds ...gen.Condition) IWinCustomerDo {
	return w.withDO(w.DO.Having(conds...))
}

func (w winCustomerDo) Limit(limit int) IWinCustomerDo {
	return w.withDO(w.DO.Limit(limit))
}

func (w winCustomerDo) Offset(offset int) IWinCustomerDo {
	return w.withDO(w.DO.Offset(offset))
}

func (w winCustomerDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IWinCustomerDo {
	return w.withDO(w.DO.Scopes(funcs...))
}

func (w winCustomerDo) Unscoped() IWinCustomerDo {
	return w.withDO(w.DO.Unscoped())
}

func (w winCustomerDo) Create(values ...*model.WinCustomer) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Create(values)
}

func (w winCustomerDo) CreateInBatches(values []*model.WinCustomer, batchSize int) error {
	return w.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (w winCustomerDo) Save(values ...*model.WinCustomer) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Save(values)
}

func (w winCustomerDo) First() (*model.WinCustomer, error) {
	if result, err := w.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.WinCustomer), nil
	}
}

func (w winCustomerDo) Take() (*model.WinCustomer, error) {
	if result, err := w.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.WinCustomer), nil
	}
}

func (w winCustomerDo) Last() (*model.WinCustomer, error) {
	if result, err := w.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.WinCustomer), nil
	}
}

func (w winCustomerDo) Find() ([]*model.WinCustomer, error) {
	result, err := w.DO.Find()
	return result.([]*model.WinCustomer), err
}

func (w winCustomerDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.WinCustomer, err error) {
	buf := make([]*model.WinCustomer, 0, batchSize)
	err = w.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (w winCustomerDo) FindInBatches(result *[]*model.WinCustomer, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return w.DO.FindInBatches(result, batchSize, fc)
}

func (w winCustomerDo) Attrs(attrs ...field.AssignExpr) IWinCustomerDo {
	return w.withDO(w.DO.Attrs(attrs...))
}

func (w winCustomerDo) Assign(attrs ...field.AssignExpr) IWinCustomerDo {
	return w.withDO(w.DO.Assign(attrs...))
}

func (w winCustomerDo) Joins(fields ...field.RelationField) IWinCustomerDo {
	for _, _f := range fields {
		w = *w.withDO(w.DO.Joins(_f))
	}
	return &w
}

func (w winCustomerDo) Preload(fields ...field.RelationField) IWinCustomerDo {
	for _, _f := range fields {
		w = *w.withDO(w.DO.Preload(_f))
	}
	return &w
}

func (w winCustomerDo) FirstOrInit() (*model.WinCustomer, error) {
	if result, err := w.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.WinCustomer), nil
	}
}

func (w winCustomerDo) FirstOrCreate() (*model.WinCustomer, error) {
	if result, err := w.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.WinCustomer), nil
	}
}

func (w winCustomerDo) FindByPage(offset int, limit int) (result []*model.WinCustomer, count int64, err error) {
	result, err = w.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = w.Offset(-1).Limit(-1).Count()
	return
}

func (w winCustomerDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = w.Count()
	if err != nil {
		return
	}

	err = w.Offset(offset).Limit(limit).Scan(result)
	return
}

func (w winCustomerDo) Scan(result interface{}) (err error) {
	return w.DO.Scan(result)
}

func (w winCustomerDo) Delete(models ...*model.WinCustomer) (result gen.ResultInfo, err error) {
	return w.DO.Delete(models)
}

func (w *winCustomerDo) withDO(do gen.Dao) *winCustomerDo {
	w.DO = *do.(*gen.DO)
	return w
}
