// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/gzorm/commons/zorm/model"
)

func newFbSportsMatchMarkets(db *gorm.DB, opts ...gen.DOOption) fbSportsMatchMarkets {
	_fbSportsMatchMarkets := fbSportsMatchMarkets{}

	_fbSportsMatchMarkets.fbSportsMatchMarketsDo.UseDB(db, opts...)
	_fbSportsMatchMarkets.fbSportsMatchMarketsDo.UseModel(&model.FbSportsMatchMarkets{})

	tableName := _fbSportsMatchMarkets.fbSportsMatchMarketsDo.TableName()
	_fbSportsMatchMarkets.ALL = field.NewAsterisk(tableName)
	_fbSportsMatchMarkets.ID = field.NewInt64(tableName, "id")
	_fbSportsMatchMarkets.MatchID = field.NewInt64(tableName, "match_id")
	_fbSportsMatchMarkets.Mty = field.NewInt64(tableName, "mty")
	_fbSportsMatchMarkets.Pe = field.NewInt64(tableName, "pe")
	_fbSportsMatchMarkets.Tps = field.NewString(tableName, "tps")
	_fbSportsMatchMarkets.Nm = field.NewString(tableName, "nm")
	_fbSportsMatchMarkets.Mks = field.NewString(tableName, "mks")

	_fbSportsMatchMarkets.fillFieldMap()

	return _fbSportsMatchMarkets
}

// fbSportsMatchMarkets 赛事玩法表
type fbSportsMatchMarkets struct {
	fbSportsMatchMarketsDo

	ALL     field.Asterisk
	ID      field.Int64
	MatchID field.Int64  // 赛事ID，关联matches表
	Mty     field.Int64  // 玩法类型，如亚盘、大小球等
	Pe      field.Int64  // 玩法阶段，如足球上半场、全场等
	Tps     field.String // 玩法展示分类数组，如：热门、角球、波胆等
	Nm      field.String // 玩法名称
	Mks     field.String // 玩法赔率集合 (JSON存储)

	fieldMap map[string]field.Expr
}

func (f fbSportsMatchMarkets) Table(newTableName string) *fbSportsMatchMarkets {
	f.fbSportsMatchMarketsDo.UseTable(newTableName)
	return f.updateTableName(newTableName)
}

func (f fbSportsMatchMarkets) As(alias string) *fbSportsMatchMarkets {
	f.fbSportsMatchMarketsDo.DO = *(f.fbSportsMatchMarketsDo.As(alias).(*gen.DO))
	return f.updateTableName(alias)
}

func (f *fbSportsMatchMarkets) updateTableName(table string) *fbSportsMatchMarkets {
	f.ALL = field.NewAsterisk(table)
	f.ID = field.NewInt64(table, "id")
	f.MatchID = field.NewInt64(table, "match_id")
	f.Mty = field.NewInt64(table, "mty")
	f.Pe = field.NewInt64(table, "pe")
	f.Tps = field.NewString(table, "tps")
	f.Nm = field.NewString(table, "nm")
	f.Mks = field.NewString(table, "mks")

	f.fillFieldMap()

	return f
}

func (f *fbSportsMatchMarkets) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := f.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (f *fbSportsMatchMarkets) fillFieldMap() {
	f.fieldMap = make(map[string]field.Expr, 7)
	f.fieldMap["id"] = f.ID
	f.fieldMap["match_id"] = f.MatchID
	f.fieldMap["mty"] = f.Mty
	f.fieldMap["pe"] = f.Pe
	f.fieldMap["tps"] = f.Tps
	f.fieldMap["nm"] = f.Nm
	f.fieldMap["mks"] = f.Mks
}

func (f fbSportsMatchMarkets) clone(db *gorm.DB) fbSportsMatchMarkets {
	f.fbSportsMatchMarketsDo.ReplaceConnPool(db.Statement.ConnPool)
	return f
}

func (f fbSportsMatchMarkets) replaceDB(db *gorm.DB) fbSportsMatchMarkets {
	f.fbSportsMatchMarketsDo.ReplaceDB(db)
	return f
}

type fbSportsMatchMarketsDo struct{ gen.DO }

type IFbSportsMatchMarketsDo interface {
	gen.SubQuery
	Debug() IFbSportsMatchMarketsDo
	WithContext(ctx context.Context) IFbSportsMatchMarketsDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IFbSportsMatchMarketsDo
	WriteDB() IFbSportsMatchMarketsDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IFbSportsMatchMarketsDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IFbSportsMatchMarketsDo
	Not(conds ...gen.Condition) IFbSportsMatchMarketsDo
	Or(conds ...gen.Condition) IFbSportsMatchMarketsDo
	Select(conds ...field.Expr) IFbSportsMatchMarketsDo
	Where(conds ...gen.Condition) IFbSportsMatchMarketsDo
	Order(conds ...field.Expr) IFbSportsMatchMarketsDo
	Distinct(cols ...field.Expr) IFbSportsMatchMarketsDo
	Omit(cols ...field.Expr) IFbSportsMatchMarketsDo
	Join(table schema.Tabler, on ...field.Expr) IFbSportsMatchMarketsDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IFbSportsMatchMarketsDo
	RightJoin(table schema.Tabler, on ...field.Expr) IFbSportsMatchMarketsDo
	Group(cols ...field.Expr) IFbSportsMatchMarketsDo
	Having(conds ...gen.Condition) IFbSportsMatchMarketsDo
	Limit(limit int) IFbSportsMatchMarketsDo
	Offset(offset int) IFbSportsMatchMarketsDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IFbSportsMatchMarketsDo
	Unscoped() IFbSportsMatchMarketsDo
	Create(values ...*model.FbSportsMatchMarkets) error
	CreateInBatches(values []*model.FbSportsMatchMarkets, batchSize int) error
	Save(values ...*model.FbSportsMatchMarkets) error
	First() (*model.FbSportsMatchMarkets, error)
	Take() (*model.FbSportsMatchMarkets, error)
	Last() (*model.FbSportsMatchMarkets, error)
	Find() ([]*model.FbSportsMatchMarkets, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.FbSportsMatchMarkets, err error)
	FindInBatches(result *[]*model.FbSportsMatchMarkets, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.FbSportsMatchMarkets) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IFbSportsMatchMarketsDo
	Assign(attrs ...field.AssignExpr) IFbSportsMatchMarketsDo
	Joins(fields ...field.RelationField) IFbSportsMatchMarketsDo
	Preload(fields ...field.RelationField) IFbSportsMatchMarketsDo
	FirstOrInit() (*model.FbSportsMatchMarkets, error)
	FirstOrCreate() (*model.FbSportsMatchMarkets, error)
	FindByPage(offset int, limit int) (result []*model.FbSportsMatchMarkets, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IFbSportsMatchMarketsDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (f fbSportsMatchMarketsDo) Debug() IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.Debug())
}

func (f fbSportsMatchMarketsDo) WithContext(ctx context.Context) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.WithContext(ctx))
}

func (f fbSportsMatchMarketsDo) ReadDB() IFbSportsMatchMarketsDo {
	return f.Clauses(dbresolver.Read)
}

func (f fbSportsMatchMarketsDo) WriteDB() IFbSportsMatchMarketsDo {
	return f.Clauses(dbresolver.Write)
}

func (f fbSportsMatchMarketsDo) Session(config *gorm.Session) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.Session(config))
}

func (f fbSportsMatchMarketsDo) Clauses(conds ...clause.Expression) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.Clauses(conds...))
}

func (f fbSportsMatchMarketsDo) Returning(value interface{}, columns ...string) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.Returning(value, columns...))
}

func (f fbSportsMatchMarketsDo) Not(conds ...gen.Condition) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.Not(conds...))
}

func (f fbSportsMatchMarketsDo) Or(conds ...gen.Condition) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.Or(conds...))
}

func (f fbSportsMatchMarketsDo) Select(conds ...field.Expr) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.Select(conds...))
}

func (f fbSportsMatchMarketsDo) Where(conds ...gen.Condition) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.Where(conds...))
}

func (f fbSportsMatchMarketsDo) Order(conds ...field.Expr) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.Order(conds...))
}

func (f fbSportsMatchMarketsDo) Distinct(cols ...field.Expr) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.Distinct(cols...))
}

func (f fbSportsMatchMarketsDo) Omit(cols ...field.Expr) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.Omit(cols...))
}

func (f fbSportsMatchMarketsDo) Join(table schema.Tabler, on ...field.Expr) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.Join(table, on...))
}

func (f fbSportsMatchMarketsDo) LeftJoin(table schema.Tabler, on ...field.Expr) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.LeftJoin(table, on...))
}

func (f fbSportsMatchMarketsDo) RightJoin(table schema.Tabler, on ...field.Expr) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.RightJoin(table, on...))
}

func (f fbSportsMatchMarketsDo) Group(cols ...field.Expr) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.Group(cols...))
}

func (f fbSportsMatchMarketsDo) Having(conds ...gen.Condition) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.Having(conds...))
}

func (f fbSportsMatchMarketsDo) Limit(limit int) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.Limit(limit))
}

func (f fbSportsMatchMarketsDo) Offset(offset int) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.Offset(offset))
}

func (f fbSportsMatchMarketsDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.Scopes(funcs...))
}

func (f fbSportsMatchMarketsDo) Unscoped() IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.Unscoped())
}

func (f fbSportsMatchMarketsDo) Create(values ...*model.FbSportsMatchMarkets) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Create(values)
}

func (f fbSportsMatchMarketsDo) CreateInBatches(values []*model.FbSportsMatchMarkets, batchSize int) error {
	return f.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (f fbSportsMatchMarketsDo) Save(values ...*model.FbSportsMatchMarkets) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Save(values)
}

func (f fbSportsMatchMarketsDo) First() (*model.FbSportsMatchMarkets, error) {
	if result, err := f.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.FbSportsMatchMarkets), nil
	}
}

func (f fbSportsMatchMarketsDo) Take() (*model.FbSportsMatchMarkets, error) {
	if result, err := f.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.FbSportsMatchMarkets), nil
	}
}

func (f fbSportsMatchMarketsDo) Last() (*model.FbSportsMatchMarkets, error) {
	if result, err := f.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.FbSportsMatchMarkets), nil
	}
}

func (f fbSportsMatchMarketsDo) Find() ([]*model.FbSportsMatchMarkets, error) {
	result, err := f.DO.Find()
	return result.([]*model.FbSportsMatchMarkets), err
}

func (f fbSportsMatchMarketsDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.FbSportsMatchMarkets, err error) {
	buf := make([]*model.FbSportsMatchMarkets, 0, batchSize)
	err = f.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (f fbSportsMatchMarketsDo) FindInBatches(result *[]*model.FbSportsMatchMarkets, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return f.DO.FindInBatches(result, batchSize, fc)
}

func (f fbSportsMatchMarketsDo) Attrs(attrs ...field.AssignExpr) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.Attrs(attrs...))
}

func (f fbSportsMatchMarketsDo) Assign(attrs ...field.AssignExpr) IFbSportsMatchMarketsDo {
	return f.withDO(f.DO.Assign(attrs...))
}

func (f fbSportsMatchMarketsDo) Joins(fields ...field.RelationField) IFbSportsMatchMarketsDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Joins(_f))
	}
	return &f
}

func (f fbSportsMatchMarketsDo) Preload(fields ...field.RelationField) IFbSportsMatchMarketsDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Preload(_f))
	}
	return &f
}

func (f fbSportsMatchMarketsDo) FirstOrInit() (*model.FbSportsMatchMarkets, error) {
	if result, err := f.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.FbSportsMatchMarkets), nil
	}
}

func (f fbSportsMatchMarketsDo) FirstOrCreate() (*model.FbSportsMatchMarkets, error) {
	if result, err := f.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.FbSportsMatchMarkets), nil
	}
}

func (f fbSportsMatchMarketsDo) FindByPage(offset int, limit int) (result []*model.FbSportsMatchMarkets, count int64, err error) {
	result, err = f.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = f.Offset(-1).Limit(-1).Count()
	return
}

func (f fbSportsMatchMarketsDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = f.Count()
	if err != nil {
		return
	}

	err = f.Offset(offset).Limit(limit).Scan(result)
	return
}

func (f fbSportsMatchMarketsDo) Scan(result interface{}) (err error) {
	return f.DO.Scan(result)
}

func (f fbSportsMatchMarketsDo) Delete(models ...*model.FbSportsMatchMarkets) (result gen.ResultInfo, err error) {
	return f.DO.Delete(models)
}

func (f *fbSportsMatchMarketsDo) withDO(do gen.Dao) *fbSportsMatchMarketsDo {
	f.DO = *do.(*gen.DO)
	return f
}
